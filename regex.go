package fsm

import (
	"fmt"
	"regexp/syntax"
)

// ParseRegex parses a regular expression and returns
// an NFA that accepts the same language. The actual parsing
// legwork is done by Go's regexp/syntax package; ParseRegex
// traverses the AST generated by regexp/syntax and compiles
// the AST into an NFA.
// An important precondition is that, since regexp/syntax
// was designed to work on printable strings, the transitions
// in the output NFA are "runes", which are equivalent to int32.
func ParseRegex(pattern string) (*NFA, error) {
	ast, err := syntax.Parse(pattern, syntax.POSIX)
	if err != nil {
		return nil, err
	}
	return astTraverse(ast)
}

func astTraverse(ast *syntax.Regexp) (*NFA, error) {
	switch ast.Op {
	case syntax.OpNoMatch:
		// the language of ast is the empty set
		return emptySetNFA(), nil
	case syntax.OpEmptyMatch:
		// the language of ast is the empty string
		return emptyStringNFA(), nil
	case syntax.OpLiteral:
		// the language of ast is exactly one string
		return literalStringNFA(ast.Rune), nil
	case syntax.OpCharClass:
		// the language of ast is a range of runes
		return charClassNFA(ast.Rune), nil
	case syntax.OpAnyCharNotNL:
		// the language of ast is any character except a newline
		return nil, fmt.Errorf("Op not supported: syntax.OpAnyCharNotNL")
	case syntax.OpAnyChar:
		// what is a rune? Is it ascii or utf8? is it possible to know at runtime?
		// more research needed
		return nil, fmt.Errorf("Op not supported (yet): syntax.OpAnyChar")
	case syntax.OpBeginLine:
	case syntax.OpEndLine:
	case syntax.OpBeginText:
	case syntax.OpEndText:
	case syntax.OpWordBoundary:
	case syntax.OpNoWordBoundary:
	case syntax.OpCapture:
		// All of these features are incredibly useful for a normal regex library, but don't
		// have much meaning or usefulness in the context of an NFA.
		return nil, fmt.Errorf("Advanced regex operations not supported. See source for details")
	case syntax.OpStar:
		// now we're getting interesting!
		// the language of ast is ast.Sub[0] zero or more times
		subexpNFA, err := astTraverse(ast.Sub[0])
		// subexpNFA is a language that accepts ast.Sub[0]
		// bubble up errors in recursion
		if err != nil {
			return nil, err
		}
		return starNFA(subexpNFA), nil
	case syntax.OpPlus:
		// (regex)+ = regex(regex)*
		subexpNFA, err := astTraverse(ast.Sub[0])
		if err != nil {
			return nil, err
		}
		return concatNFA(subexpNFA, starNFA(subexpNFA)), nil
	case syntax.OpQuest:
		// regex? = epsilon | regex
		subexpNFA, err := astTraverse(ast.Sub[0])
		if err != nil {
			return nil, err
		}
		return unionNFA(emptyStringNFA(), subexpNFA), nil
	case syntax.OpRepeat:
		// not supported, not sure if i ever want to do this one
		return nil, fmt.Errorf("Repeat operation not supported")
	case syntax.OpConcat:
		// this, along with star and union, is a fundamental operation
		// on an nfa.
		nfa_arr := make([]*NFA, len(ast.Sub))
		for i := 0; i < len(ast.Sub); i++ {
			result, err := astTraverse(ast.Sub[i])
			if err != nil {
				return nil, err
			}
			nfa_arr[i] = result
		}
		nfa_acc := nfa_arr[0]
		// reduces from left to right
		for i := 1; i < len(ast.Sub); i++ {
			nfa_acc = concatNFA(nfa_acc, nfa_arr[i])
		}
		return nfa_acc, nil
	case syntax.OpAlternate:
		// NFA union operation
		nfa_arr := make([]*NFA, len(ast.Sub))
		for i := 0; i < len(ast.Sub); i++ {
			result, err := astTraverse(ast.Sub[i])
			if err != nil {
				return nil, err
			}
			nfa_arr[i] = result
		}
		nfa_acc := nfa_arr[0]
		for i := 1; i < len(ast.Sub); i++ {
			nfa_acc = unionNFA(nfa_acc, nfa_arr[i])
		}
		return nfa_acc, nil
	default:
		return nil, fmt.Errorf("Unknown operation")
	}
	return nil, fmt.Errorf("Uknown operation")
}

// Creates a new NFA that accepts no strings.
func emptySetNFA() *NFA {
	n := NewNFA()
	s1 := n.NewState()
	s1.IsAccepting = false
	return n
}

// Creates a new NFA that accepts the empty string.
func emptyStringNFA() *NFA {
	// if an NFA tries to make a transition where there is none, it rejects.
	n := NewNFA()
	s1, s2 := n.NewState(), n.NewState()
	s1.NewEdge(Epsilon, s2)
	s2.IsAccepting = true
	return n
}

// Creates a new NFA that accepts a literal string given by the
// slice of runes parameter.
func literalStringNFA(runes []rune) *NFA {
	n := NewNFA()
	s_prev := n.NewState()
	var s_next *State
	for r := range runes {
		s_next = n.NewState()
		s_prev.NewEdge(r, s_next)
		s_prev = s_next
	}
	s_prev.IsAccepting = true
	return n
}

func charClassNFA(runes []rune) *NFA {
	// sanity checks for development
	if (len(runes) & 1) != 0 {
		panic("CharClass array not even, what is going on?!")
	}
	n := NewNFA()
	s1, s2 := n.NewState(), n.NewState()
	s2.IsAccepting = true
	// in a char class, runes is a list of pairs
	// the first is the start of the range, and the second
	// is the end of the range. There may be any number of
	// pairs, so we count by 2.
	for i := 0; i < len(runes); i += 2 {
		for j := runes[i]; j <= runes[i+1]; j++ {
			s1.NewEdge(int(j), s2)
		}
	}
	return n
}

// Given an NFA as an input, returns an NFA that
// accepts the language of the input NFA zero or more times
// See http://upload.wikimedia.org/wikipedia/commons/8/8e/Thompson-kleene-star.svg
// for a drawing of this logic
// This function clobbers the parameter.
func starNFA(nfa *NFA) *NFA {
	src, sink := nfa.NewState(), nfa.NewState()
	src.NewEdge(Epsilon, nfa.Start())
	src.NewEdge(Epsilon, sink)
	for _, s := range nfa.List() {
		if s.IsAccepting {
			s.NewEdge(Epsilon, sink)
			s.NewEdge(Epsilon, nfa.Start())
		}
	}
	nfa.SetStart(src)
	return nfa
}

// Given two NFAs as inputs, returns an NFA
// that accepts the language of the first NFA
// followed by the language of the second NFA.
// This function clobbers the first parameter, and
// fatally alters the second NFA. Neither should be
// used after a call to this function.
func concatNFA(first, second *NFA) *NFA {
	// tell all of second's states that they belong to
	// first now
	for _, s := range second.List() {
		s.nfa = first
	}
	// all accept states of the first NFA have epsilon
	// transitions to the start state of second
	for _, s := range first.List() {
		if s.IsAccepting {
			s.NewEdge(Epsilon, second.Start())
		}
	}
	return first
}

// Given two NFAs as inputs, returns an NFA
// that accepts the if a string is accepted
// in either NFA. The parameters are clobbered the same
// was as concatNFA.
func unionNFA(first, second *NFA) *NFA {
	src, sink := first.NewState(), first.NewState()
	for _, s := range second.List() {
		s.nfa = first
	}
	src.NewEdge(Epsilon, first.Start())
	src.NewEdge(Epsilon, second.Start())
	for _, s := range first.List() {
		if s.IsAccepting {
			s.NewEdge(Epsilon, sink)
		}
	}
	return first
}
