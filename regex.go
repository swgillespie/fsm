package main

import (
	"regexp/syntax"
	"fmt"
)

// ParseRegex parses a regular expression and returns
// an NFA that accepts the same language. The actual parsing
// legwork is done by Go's regexp/syntax package; ParseRegex
// traverses the AST generated by regexp/syntax and compiles
// the AST into an NFA.
// An important precondition is that, since regexp/syntax
// was designed to work on printable strings, the transitions
// in the output NFA are "runes", which are equivalent to int32.
func ParseRegex(pattern string) (*NFA, error) {
	ast, err := syntax.Parse(string, syntax.POSIX)
	if (err != nil) {
		return nil, err
	}
	return astTraverse(ast)
}

func astTraverse(ast *syntax.Regexp) (*NFA, error) {
	switch ast.Op {
	case syntax.OpNoMatch:
		// the language of ast is the empty set
		return emptySetNFA(), nil
	case syntax.OpEmptyMatch:
		// the language of ast is the empty string
		return emptyStringNFA(), nil
	case syntax.OpLiteral:
		// the language of ast is exactly one string
		return literalStringNFA(ast.Rune), nil
	case syntax.OpCharClass:
		// the language of ast is a range of runes
		return charClassNFA(ast.Rune), nil
	case syntax.OpAnyCharNotNL:
		// the language of ast is any character except a newline
		return nil, fmt.Errorf("Op not supported: syntax.OpAnyCharNotNL")
	case syntax.OpAnyChar:
		// what is a rune? Is it ascii or utf8? is it possible to know at runtime?
		// more research needed
		return nil, fmt.Errorf("Op not supported (yet): syntax.OpAnyChar")
	case syntax.OpBeginLine:
	case syntax.OpEndLine:
	case syntax.OpBeginText:
	case syntax.OpEndText:
	case syntax.OpWordBoundary:
	case syntax.OpNoWordBoundary:
	case syntax.OpCapture:
		// All of these features are incredibly useful for a normal regex library, but don't
		// have much meaning or usefulness in the context of an NFA. 
		return nil, fmt.Errorf("Advanced regex operations not supported. See source for details")
	case syntax.OpStar:
		// now we're getting interesting!
		// the language of ast is ast.Sub[0] zero or more times
		subexpNFA, err := astTraverse(ast.Sub[0])
		// subexpNFA is a language that accepts ast.Sub[0]
		// bubble up errors in recursion
		if (err != nil) {
			return nil, err
		}
		return starNFA(subexpNFA), nil
	}
	// INCOMPLETE
}

// Creates a new NFA that accepts no strings.
func emptySetNFA() *NFA {
	n := NewNFA()
	s1 := n.NewState()
	s1.IsAccepting = false
	return n
}

// Creates a new NFA that accepts the empty string.
func emptyStringNFA() *NFA {
	// if an NFA tries to make a transition where there is none, it rejects.
	n := NewNFA()
	s1 := n.NewState()
	s1.IsAccepting = true
	return n
}

// Creates a new NFA that accepts a literal string given by the
// slice of runes parameter.
func literalStringNFA(runes []rune) *NFA {
	n := NewNFA()
	s_prev := n.NewState()
	s_next := nil
	for r := range runes {
		s_next = n.NewState()
		s_prev.NewEdge(r, s_next)
		s_prev = s_next
	}
	s_prev.IsAccepting = true
	return n
}

func charClassNFA(runes []rune) *NFA {
	// sanity checks for development
	if len(runes) & 1 {
		panic("CharClass array not even, what is going on?!")
	}
	n := NewNFA()
	s1, s2 := n.NewState(), n.NewState()
	s2.IsAccepting = true
	// in a char class, runes is a list of pairs
	// the first is the start of the range, and the second
	// is the end of the range. There may be any number of
	// pairs, so we count by 2.
	for i := 0; i < len(runes); i += 2 {
		for j := runes[i]; j <= runes[i + 1]; j++ {
			s1.NewEdge(j, s2)
		}
	}
	return n
}

// Given an NFA as an input, returns an NFA that
// accepts the language of the input NFA zero or more times
func starNFA(nfa *NFA) (*NFA) {
	// done hacking for a little while
}


